#version 460
#extension GL_EXT_buffer_reference : require

#include "lights.h"
#include "pbr.h"

#ifdef USE_TILED_LIGHTS
	#include "tiled_lighting.h"
#endif

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba16f,set = 0, binding = 0) uniform readonly image2D inWorldSpacePositionMetallic;
layout(rgba16f,set = 0, binding = 1) uniform readonly image2D inWorldSpaceNormalRoughness;
layout(rgba8,set = 0, binding = 2) uniform readonly image2D inAlbedoAO;
layout (set = 0, binding = 3) uniform sampler2D inDepthBuffer;
layout(set = 0, binding = 4) uniform writeonly image2D hdrOutput;

// send lighting buffer address via push constat
layout(push_constant) uniform constants
{
	vec4 m_cameraWorldSpacePos;
	LightsBuffer m_allLights;
#ifdef USE_TILED_LIGHTS
	LightTileMetadataBuffer m_lightTileMetadata;
#endif
} PushConstants;

#ifndef USE_TILED_LIGHTS
	// Copy all pointlights to shared memory for this work group
	#define MAX_SHARED_LIGHTS 1024
	shared Pointlight sharedLights[MAX_SHARED_LIGHTS];
#endif

void main() 
{
	LightsData lightsData = PushConstants.m_allLights.data[0];
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(hdrOutput);
	float depthValue = texelFetch(inDepthBuffer, texelCoord, 0).r;
	
#ifndef USE_TILED_LIGHTS
	// Copy lights list to shared memory, up to 4 lights per thread
	uint pointLightCount = min(lightsData.m_pointlightCount, MAX_SHARED_LIGHTS);
	uint firstLightIndex = gl_LocalInvocationIndex * 4;
	uint lastLightIndex = min(firstLightIndex + 4, pointLightCount);
	for(uint p=firstLightIndex;p<lastLightIndex;++p)
	{
		sharedLights[p] = lightsData.m_allPointlights.data[p];
	}
	groupMemoryBarrier ();		// ensure all writes to shared memory complete for this group
	barrier();		// synchronise all invocations in this group
#endif

	if(texelCoord.x < size.x && texelCoord.y < size.y)
	{
		vec3 finalLight = lightsData.m_skyColourAmbient.xyz;	// apply sky colour if no depth was written (probably should be a separate sky/skybox pass later)
		if(depthValue != 1.0)
		{
			vec4 positionMetallic = imageLoad(inWorldSpacePositionMetallic, texelCoord);
			vec4 normalRoughness = imageLoad(inWorldSpaceNormalRoughness, texelCoord);
			vec4 albedoAO = imageLoad(inAlbedoAO, texelCoord);
			vec3 viewDir = normalize(PushConstants.m_cameraWorldSpacePos.xyz - positionMetallic.xyz);
			
			PBRMaterial mat;	// set up PBR material params from gbuffer
			mat.m_albedo = albedoAO.xyz;
			mat.m_roughness = normalRoughness.w;
			mat.m_metallic = positionMetallic.w;
			mat.m_ao = albedoAO.w;

			// Apply sun direct light
			vec4 sunDirectionBrightness = lightsData.m_sunDirectionBrightness;
			vec3 sunRadiance = lightsData.m_sunColourAmbient.xyz * sunDirectionBrightness.w;
			vec3 directLight = PBRDirectLighting(mat, viewDir, -sunDirectionBrightness.xyz, normalRoughness.xyz, sunRadiance, 1.0);
			
			// Apply point lights (direct)
#ifdef USE_TILED_LIGHTS
			LightTileMetadata tileMetadata = PushConstants.m_lightTileMetadata.data[0];
			uint tileIndex = GetLightTileIndex(uvec2(gl_GlobalInvocationID.xy), tileMetadata);
			uint pointLightCount = uint(tileMetadata.m_lightTiles.data[tileIndex].m_lightCount);
			for(uint l=0;l<pointLightCount;++l)
			{
				uint p = uint(tileMetadata.m_lightTiles.data[tileIndex].m_lightIndices[l]);
				Pointlight pl = lightsData.m_allPointlights.data[p];
#else
			for(uint p=0;p<pointLightCount;++p)
			{
				Pointlight pl = sharedLights[p];
#endif
				vec3 lightRadiance = pl.m_colourBrightness.xyz * pl.m_colourBrightness.w;
				float attenuation = GetPointlightAttenuation(pl, positionMetallic.xyz);
				vec3 lightToPixel = normalize(pl.m_positionDistance.xyz - positionMetallic.xyz);
				directLight += PBRDirectLighting(mat, viewDir, lightToPixel, normalRoughness.xyz, lightRadiance, attenuation);
			}
			
			// Ambient is a hack, tries to combine sky + sun colour somehow
			vec3 ambient = PBRGetAmbientLighting(mat, 
				lightsData.m_sunColourAmbient.xyz, 
				lightsData.m_sunColourAmbient.w,
				lightsData.m_skyColourAmbient.xyz,
				lightsData.m_skyColourAmbient.w
			);
			
			finalLight = ambient + directLight;
		}
		imageStore(hdrOutput, texelCoord, vec4(finalLight,1.0));
	}
}